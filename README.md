# Smart Issue Board

A production-ready web application for managing and tracking issues with a focus on simplicity, clean code, and intelligent issue detection.

## Technology Stack

### Frontend
- **Next.js 16** (App Router) - Modern React framework with file-based routing and server components
- **JavaScript (ES6+)** - Simple, flexible, and beginner-friendly
- **Tailwind CSS** - Utility-first CSS for rapid UI development
- **shadcn/ui** - Pre-built, customizable React components

**Why Next.js?**
- Server-side rendering (SSR) and static site generation (SSG) for optimal performance
- Built-in API routes and middleware support
- Vercel deployment integration with zero configuration
- Excellent TypeScript support out of the box
- Perfect for full-stack applications with minimal boilerplate

### Backend & Database
- **Firebase Firestore** - NoSQL cloud database with real-time capabilities
- **Firebase Authentication** - Built-in user management with email/password auth

**Why Firestore?**
- Simplicity: No server infrastructure to manage
- Real-time database with automatic synchronization
- Built-in security rules for data protection
- Scales automatically with demand
- Generous free tier for development

### Hosting
- **Vercel** - Optimal deployment platform for Next.js applications

## Project Structure

```
smart-issue-board/
├── app/
│   ├── layout.tsx              # Root layout with AuthProvider
│   ├── globals.css             # Global styles and design tokens
│   ├── page.tsx                # Home page (redirect logic)
│   ├── login/
│   │   └── page.tsx            # Login page
│   ├── signup/
│   │   └── page.tsx            # Signup page
│   └── dashboard/
│       └── page.tsx            # Main dashboard with issues
├── components/
│   ├── ui/                     # shadcn/ui components
│   ├── login-form.tsx          # Login form component
│   ├── signup-form.tsx         # Signup form component
│   ├── dashboard-header.tsx    # Header with user info & logout
│   ├── protected-layout.tsx    # Auth protection wrapper
│   ├── create-issue-form.tsx   # Issue creation form
│   ├── issue-list.tsx          # Issue list component
│   ├── issue-card.tsx          # Individual issue card
│   ├── issue-filters.tsx       # Filter controls
│   └── filtered-issue-list.tsx # Filtered issues display
├── lib/
│   ├── firebase.ts             # Firebase SDK initialization
│   ├── auth-context.tsx        # Auth context & hooks
│   ├── firestore-utils.ts      # Firestore CRUD operations
│   └── status-transitions.ts   # Status validation logic
├── .env.local.example          # Environment variables template
├── vercel.json                 # Vercel deployment config
└── README.md                   # This file
```

## Core Features

### 1. Authentication
- Email/password signup and login using Firebase Auth
- Auth state managed via React Context for app-wide access
- Automatic token refresh and session management
- Protected routes with automatic redirect to login

### 2. Issue Management
Create, read, and manage issues with the following properties:
- **Title** (required) - Brief description
- **Description** - Detailed explanation
- **Priority** - Low, Medium, High
- **Status** - Open, In Progress, Done (with transition validation)
- **Assigned To** - User or team member
- **Created By** - Auto-filled with current user
- **Created At** - Auto-generated timestamp

### 3. Similar Issue Detection
When creating an issue, the system checks for similar existing issues:

**Algorithm:**
- Fetches the 50 most recent issues from Firestore
- Performs simple string comparison on titles:
  - Exact substring matching
  - Reverse substring matching
  - Word-overlap similarity (Jaccard index > 0.6)
- Shows warning with suggested similar issues if found
- User can proceed or cancel to avoid duplicates

**Example:**
Creating "Fix login button" will detect "Fix authentication button" as similar.

### 4. Status Transitions with Validation
Enforces a strict workflow:
- **Open** → In Progress (or no change)
- **In Progress** → Done (or back to Open)
- **Done** → In Progress (or no change)
- **❌ NOT allowed:** Open → Done (must go through In Progress)

If an invalid transition is attempted, user sees a friendly error message with explanation.

### 5. Filtering
Real-time filtering by:
- **Status** - Open, In Progress, Done
- **Priority** - Low, Medium, High
- **Combined filters** - Filter by status AND priority simultaneously
- **Clear button** - Reset all filters at once

Filters persist while viewing, all issues are sorted by newest first.

## Firestore Data Model

**Collection: `issues`**

Each document contains:
```typescript
{
  id: string;                                    // Auto-generated by Firestore
  title: string;                                 // "Fix login button"
  description: string;                           // Detailed explanation
  priority: "Low" | "Medium" | "High";           // Severity level
  status: "Open" | "In Progress" | "Done";       // Current state
  assignedTo: string;                            // "john@example.com"
  createdBy: string;                             // User's email (auto-filled)
  createdAt: Firestore.Timestamp;                // Auto-generated timestamp
}
```

### Indexing
No complex indexes needed. Firestore automatically indexes:
- Single field queries (status, priority)
- orderBy createdAt

### Security Rules
In production, enable Row Level Security (RLS):
- Users can only view/modify their own issues
- Implement in Firestore Rules:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /issues/{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}
```

## Getting Started

### Prerequisites
- Node.js 16+ and npm
- Firebase account (free tier available)
- Vercel account (optional, for deployment)

### Local Development

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd smart-issue-board
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```

3. **Set up Firebase**
   - Go to [Firebase Console](https://console.firebase.google.com)
   - Create a new project
   - Enable Authentication (Email/Password)
   - Create a Firestore database in production mode
   - Get your Firebase config from Project Settings

4. **Configure environment variables**
   ```bash
   cp .env.local.example .env.local
   ```
   Add your Firebase credentials to `.env.local`:
   ```
   NEXT_PUBLIC_FIREBASE_API_KEY=your_api_key
   NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com
   NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
   NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_project.appspot.com
   NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=your_sender_id
   NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id
   ```

5. **Run development server**
   ```bash
   npm run dev
   ```
   Open [http://localhost:3000](http://localhost:3000)

### Deploying to Vercel

1. **Push code to GitHub**
   ```bash
   git push origin main
   ```

2. **Deploy on Vercel**
   - Go to [vercel.com](https://vercel.com)
   - Connect your GitHub repository
   - Set environment variables in Vercel project settings
   - Deploy

3. **Verify deployment**
   - Test login/signup
   - Create an issue
   - Test filters and status transitions

## Design Decisions & Rationale

### Frontend Architecture
- **React Context over Redux** - Simple, lightweight state management for auth
- **Server Components by default** - Better performance and security
- **Component composition** - Small, reusable components for maintainability

### Similar Issue Detection
- **Simple string matching** - No AI/ML needed; string operations are fast
- **Recent issues only** - Checking last 50 issues is efficient
- **Client-side filtering** - Reduces Firestore reads and keeps logic simple

### Status Transitions
- **Hardcoded validation logic** - Clear, predictable behavior
- **Prevents workflow bugs** - Can't accidentally mark issue as "Done"
- **Friendly error messages** - Users understand why action failed

### Firestore Usage
- **No transactions** - Single document updates are atomic
- **No complex queries** - Simple equality and orderBy filters
- **Timestamps over dates** - Firestore timestamps are more reliable

## Challenges & Solutions

### Challenge 1: Similar Issue Detection Performance
**Problem:** Checking all issues for similarity could be slow.

**Solution:** 
- Limit search to 50 most recent issues
- Use simple string matching instead of ML embeddings
- Client-side filtering after fetching

### Challenge 2: Auth State Persistence
**Problem:** Auth state lost on page refresh.

**Solution:**
- Use Firebase `onAuthStateChanged` listener
- Maintains auth in React Context across navigations
- AuthProvider in root layout ensures app-wide access

### Challenge 3: Status Transition Validation
**Problem:** Firestore doesn't prevent invalid writes.

**Solution:**
- Implement validation logic in TypeScript
- Check before sending update to Firestore
- Show error message and prevent invalid transitions

## Future Improvements

1. **Caching & Optimizations**
   - Add SWR/React Query for smart data fetching
   - Cache issue list locally to reduce Firestore reads
   - Implement pagination for large issue lists

2. **Advanced Features**
   - Issue comments and activity timeline
   - Multiple assignees and teams
   - Custom priority/status fields
   - Export issues to CSV

3. **Admin Dashboard**
   - User management
   - Issue analytics and metrics
   - System health monitoring

4. **Real-time Collaboration**
   - Live updates when others modify issues
   - Presence indicators
   - Collaborative editing

5. **Testing**
   - Unit tests for utilities (status transitions, similarity)
   - Integration tests for Firestore operations
   - E2E tests with Cypress/Playwright

6. **Security Enhancements**
   - Rate limiting on issue creation
   - Input validation and sanitization
   - Firestore RLS policies for multi-user isolation

## Confusing Parts & Clarifications

### Why is `createdBy` a string, not a user object?
- Simplicity: Storing just email is sufficient for this project
- Performance: No need for joins or nested queries
- Scalability: Easy to implement multi-user features later

### Why no real-time updates?
- Scope: Not required for internship assignment
- Complexity: Would require WebSocket setup
- Trade-off: Users manually refresh or we add polling if needed

### Why Firestore over PostgreSQL?
- Speed: No backend server to set up and manage
- Scalability: Auto-scaling built-in
- Cost: Free tier suitable for learning projects
- Real-time: Built-in real-time capabilities
- Trade-off: Less control over queries and data structure

## Code Quality

- **Clean code** - Clear naming, well-commented functions
- **Type safety** - Full TypeScript coverage
- **Error handling** - User-friendly error messages
- **Responsive design** - Works on mobile, tablet, desktop
- **Accessibility** - Semantic HTML, ARIA labels where needed

## Conclusion

Smart Issue Board demonstrates a production-ready approach to building modern web applications with Next.js, Firebase, and Vercel. The focus on simplicity, clear architecture, and thoughtful design decisions makes it an excellent template for internship projects or startup MVPs.

All technical choices are justified, trade-offs are documented, and future improvements are clearly outlined for learning and growth.

---

**Author:** Abhishek Choudhary
**Last Updated:** 29 December 2025
**Status:** Production Ready
